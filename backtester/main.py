# backtester/main.py
from fastapi import FastAPI, Query, Body
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import PlainTextResponse, JSONResponse
from collections import deque
from datetime import datetime
from typing import Deque, List
from pydantic import BaseModel

APP_TITLE = "Backtester (mock)"
DEFAULT_RING_SIZE = 20000  # запас буфера для лога

app = FastAPI(title=APP_TITLE, version="0.1.0", openapi_url="/openapi.json")

# CORS на всякий случай (фронт и гейтвей на другом origin)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# простой in-memory лог (кольцевой буфер)
LOG: Deque[str] = deque(maxlen=DEFAULT_RING_SIZE)

# list to store trades generated by backtests
BT_TRADES: List[dict] = []

def ts() -> str:
    return datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")

def log_line(line: str) -> None:
    LOG.append(f"[{ts()}] {line}")

# ——— начальные строки, чтобы не было пусто ———
log_line("backtester started")
log_line("waiting for jobs...")

@app.get("/health")
async def health():
    return {"ok": True}

@app.get("/log")
async def get_log(
    tail: int = Query(500, ge=1, le=20000, description="Сколько последних строк вернуть"),
    format: str = Query("json", regex="^(json|text)$")
):
    """
    Вернуть последние tail строк лога.
    - format=text → text/plain
    - format=json → { ok, tail, lines, text }
    """
    tail = min(tail, len(LOG))
    lines: List[str] = list(LOG)[-tail:] if tail > 0 else []
    if format == "text":
        return PlainTextResponse("\n".join(lines) + ("\n" if lines else ""))
    return JSONResponse({
        "ok": True,
        "tail": tail,
        "lines": lines,
        "text": "\n".join(lines)  # на случай если фронту удобнее сразу текстом
    })

# НЕобязательный вспомогательный эндпоинт — удобно для тестов:
@app.post("/push")
async def push(msg: str = Body(..., media_type="text/plain")):
    """
    Добавить строку в лог (для ручной проверки UI).
    Пример:
      curl -X POST http://127.0.0.1:8900/push -H "Content-Type: text/plain" --data "test message"
    """
    log_line(msg.strip())
    return {"ok": True, "size": len(LOG)}

# stub trades endpoint for compatibility with UI
@app.get("/trades")
async def trades(limit: int = 100):
    """
    Return recent trades produced by the backtest runner. If no backtests
    have been executed yet, the list will be empty. Parameter `limit`
    controls how many recent trades to return (most recent first).
    """
    limit = int(limit) if limit is not None else 100
    if limit <= 0:
        limit = 100
    if limit >= len(BT_TRADES):
        out = list(BT_TRADES)
    else:
        out = BT_TRADES[-limit:]
    return {"ok": True, "trades": out}


# data model for backtest execution
class BacktestData(BaseModel):
    """Payload to execute a simple backtest using a sequence of returns.

    The backtest assumes each return represents the profit/loss of a single
    trade. Trades with positive returns are classified as "buy", while
    negative returns are "sell". A default symbol can be provided; if
    omitted it defaults to "TEST". Quantity is fixed at 1 for simplicity.
    """
    returns: list[float]
    symbol: str | None = None


def _compute_bt_metrics(returns: list[float]) -> dict:
    """
    Compute basic performance metrics given a list of returns. Metrics include
    total PnL, win rate, Sharpe ratio, maximum drawdown, volatility,
    Value-at-Risk (95%), profit factor, Sortino ratio and average return.
    """
    if not returns:
        return {
            "pnl_total": 0.0,
            "pnl_day": 0.0,
            "win_rate": 0.0,
            "sharpe": 0.0,
            "max_drawdown": 0.0,
            "trades_count": 0,
            "avg_reward": 0.0,
            "volatility": 0.0,
            "var95": 0.0,
            "profit_factor": 0.0,
            "sortino": 0.0,
        }
    n = len(returns)
    total = sum(returns)
    pnl_total = total
    pnl_day = total  # assume all trades happen in one day
    wins = sum(1 for r in returns if r > 0)
    win_rate = wins / n if n else 0.0
    mean_r = total / n
    variance = sum((r - mean_r)**2 for r in returns) / n if n else 0.0
    std = variance**0.5
    sharpe = (mean_r / std) if std > 0 else 0.0
    volatility = std
    sorted_returns = sorted(returns)
    idx = max(0, int(0.05 * n) - 1)
    if idx < 0:
        idx = 0
    elif idx >= n:
        idx = n - 1
    var95 = -sorted_returns[idx]
    # profit factor
    sum_pos = sum(r for r in returns if r > 0)
    sum_neg = -sum(r for r in returns if r < 0)
    profit_factor = (sum_pos / sum_neg) if sum_neg > 0 else 0.0
    # sortino ratio
    downs = [r for r in returns if r < 0]
    downside_var = sum((r)**2 for r in downs) / n if n else 0.0
    downside_std = downside_var**0.5 if downside_var > 0 else 0.0
    sortino = (mean_r / downside_std) if downside_std > 0 else 0.0
    # max drawdown
    cumulative = 0.0
    peak = 0.0
    max_dd = 0.0
    for r in returns:
        cumulative += r
        if cumulative > peak:
            peak = cumulative
        dd = peak - cumulative
        if dd > max_dd:
            max_dd = dd
    return {
        "pnl_total": pnl_total,
        "pnl_day": pnl_day,
        "win_rate": win_rate,
        "sharpe": sharpe,
        "max_drawdown": max_dd,
        "trades_count": n,
        "avg_reward": mean_r,
        "volatility": volatility,
        "var95": var95,
        "profit_factor": profit_factor,
        "sortino": sortino,
    }


@app.post("/run")
async def run_backtest(data: BacktestData):
    """
    Run a simple backtest based on a sequence of returns.

    Each return is treated as the profit or loss of one trade; a positive
    return corresponds to a "buy" trade and a negative return to a "sell" trade.
    The endpoint generates a list of trade objects with unique IDs and
    computes summary performance metrics. It also appends the generated
    trades to the internal trade buffer used by `/trades`.
    
    Returns a JSON object with the generated trades and computed metrics.
    """
    returns = data.returns or []
    sym = data.symbol or "TEST"
    trades = []
    for i, r in enumerate(returns):
        side = "buy" if r >= 0 else "sell"
        qty = 1.0
        # price is the absolute value of return for illustrative purposes
        price = abs(r) if r is not None else 0.0
        trades.append({
            "id": hex(len(BT_TRADES) + i + 1),
            "ts": datetime.utcnow().isoformat(),
            "symbol": sym,
            "side": side,
            "qty": qty,
            "price": price,
            "mode": "backtest",
            "kind": "backtest"
        })
    # append to global trades buffer
    BT_TRADES.extend(trades)
    # compute metrics
    metrics = _compute_bt_metrics(returns)
    # log the run
    log_line(f"backtest run with {len(returns)} returns; pnl={metrics['pnl_total']}")
    return {"ok": True, "trades": trades, "metrics": metrics}
